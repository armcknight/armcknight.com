---
layout: modern
title: "Experience"
---

<div class="page-header">
  <h1 class="page-title">Experience</h1>
  <p class="page-subtitle">Professional background, education, and expertise</p>
</div>

{% comment %}
Era navigation section
{% endcomment %}
<div class="tags-section">
  <h2>Jump to Era:</h2>
  <div class="tag-cloud">
    <a href="#era-professional" class="tag tag-link">Professional</a>
    <a href="#era-semi-pro" class="tag tag-link">Semi-Pro</a>
    <a href="#era-amateur" class="tag tag-link">Amateur</a>
    <a href="#era-higher-education" class="tag tag-link">Higher Education</a>
    <a href="#era-primary-education" class="tag tag-link">Primary Education</a>
    <a href="#era-foodservice" class="tag tag-link">Food Service</a>
  </div>
</div>

{% comment %}
Git-style timeline - start simple with just dates
{% endcomment %}

<div class="git-timeline-container">
  <h2>Career Timeline</h2>
  
  <!-- Git-style graph view -->
  <div class="git-graph">
    <canvas id="git-canvas" width="800" height="600"></canvas>
    
    <div class="git-commits" id="git-commits">
      <!-- Simple commit list with just dates -->
      {% for job in site.data.experience.experience %}
        <div class="git-commit" 
             data-dates="{{ job.dates }}"
             data-company="{{ job.company }}"
             data-title="{{ job.title }}"
             data-era="{{ job.era }}">
          <div class="commit-dot"></div>
          <div class="commit-info">
            <span class="commit-date">{{ job.dates }}</span>
            <span class="commit-company">{{ job.company }}</span>
          </div>
        </div>
      {% endfor %}
      
      {% for edu in site.data.education.education %}
        <div class="git-commit" 
             data-dates="{{ edu.dates }}"
             data-company="{{ edu.institution }}"
             data-title="{{ edu.degree }}"
             data-era="education">
          <div class="commit-dot"></div>
          <div class="commit-info">
            <span class="commit-date">{{ edu.dates }}</span>
            <span class="commit-company">{{ edu.institution }}</span>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Simple date parser
  function parseDate(dateStr) {
    if (!dateStr) return null;
    dateStr = dateStr.trim();
    
    if (dateStr.includes('Current')) return new Date();
    
    // "January 2021" format
    const monthYearMatch = dateStr.match(/^([A-Za-z]+)\s+(\d{4})$/);
    if (monthYearMatch) {
      const month = new Date(Date.parse(monthYearMatch[1] + " 1, 2000")).getMonth();
      return new Date(parseInt(monthYearMatch[2]), month, 1);
    }
    
    // "2010" format  
    const yearMatch = dateStr.match(/^(\d{4})$/);
    if (yearMatch) {
      return new Date(parseInt(yearMatch[1]), 0, 1);
    }
    
    return null;
  }
  
  function parseDateRange(dateStr) {
    if (!dateStr) return { start: null, end: null };
    
    const parts = dateStr.split(/[-â€“]/).map(s => s.trim());
    
    // Handle "May - October 2012" format (same year range)
    if (parts.length === 2) {
      const firstPart = parts[0];
      const secondPart = parts[1];
      
      // Check if second part contains a year and first part is just a month
      const secondYear = secondPart.match(/\d{4}/);
      if (secondYear && firstPart.match(/^[A-Za-z]+$/)) {
        const year = secondYear[0];
        const startStr = `${firstPart} ${year}`;
        const endStr = secondPart;
        
        console.log(`Parsing same-year range: "${dateStr}" -> start: "${startStr}", end: "${endStr}"`);
        
        return {
          start: parseDate(startStr),
          end: parseDate(endStr)
        };
      }
    }
    
    return {
      start: parseDate(parts[0]),
      end: parts.length > 1 ? parseDate(parts[1]) : null
    };
  }
  
  // Collect all commits (start and end dates)
  let allCommits = [];
  
  // Process experience items
  const commits = document.querySelectorAll('.git-commit');
  commits.forEach(commit => {
    const dateRange = parseDateRange(commit.dataset.dates);
    const company = commit.dataset.company;
    const era = commit.dataset.era;
    
    // Skip commits with missing company data
    if (!company || company.trim() === '') {
      console.log(`Skipping commit with empty company: dates="${commit.dataset.dates}", era="${era}"`);
      return;
    }
    
    // Add start commit
    if (dateRange.start) {
      allCommits.push({
        date: dateRange.start,
        company: company,
        type: 'start',
        era: era,
        element: commit
      });
    }
    
    // Add end commit (if different from start)
    if (dateRange.end && dateRange.end.getTime() !== dateRange.start?.getTime()) {
      allCommits.push({
        date: dateRange.end,
        company: company,
        type: 'end',
        era: era,
        element: commit
      });
    }
  });
  
  // Sort chronologically (newest first)
  allCommits.sort((a, b) => b.date - a.date);
  
  console.log('Total commits:', allCommits.length);
  
  // Assign branches based on overlapping date ranges
  // Main branch = sequential career progression
  // Side branches = concurrent/overlapping activities
  const branchAssignments = {};
  
  // Group commits by company+era to get their full date ranges
  const entryRanges = {};
  allCommits.forEach(commit => {
    const key = commit.company + commit.era;
    if (!entryRanges[key]) {
      entryRanges[key] = {
        company: commit.company,
        era: commit.era,
        start: commit.date,
        end: commit.date,
        commits: []
      };
    }
    entryRanges[key].commits.push(commit);
    
    // Update the range
    if (commit.date < entryRanges[key].start) entryRanges[key].start = commit.date;
    if (commit.date > entryRanges[key].end) entryRanges[key].end = commit.date;
  });
  
  // Sort entries by start date (earliest first)
  const sortedEntries = Object.values(entryRanges).sort((a, b) => a.start - b.start);
  
  console.log('=== DEBUG: Entry ranges ===');
  sortedEntries.forEach(entry => {
    console.log(`${entry.company} (${entry.era}): ${entry.start.toLocaleDateString()} - ${entry.end.toLocaleDateString()}`);
  });
  
  // Track active ranges on each branch
  const activeBranches = [[]]; // Start with main branch (index 0)
  let nextSideBranch = 1;
  
  console.log('=== DEBUG: Branch assignments ===');
  sortedEntries.forEach(entry => {
    const key = entry.company + entry.era;
    
    // Check if this entry overlaps with any active range on the main branch
    let assignedBranch = -1;
    
    for (let branchIndex = 0; branchIndex < activeBranches.length; branchIndex++) {
      const activeBranch = activeBranches[branchIndex];
      let hasOverlap = false;
      
      for (let activeEntry of activeBranch) {
        // Check if current entry overlaps with this active entry
        if (entry.start < activeEntry.end && entry.end > activeEntry.start) {
          hasOverlap = true;
          break;
        }
      }
      
      if (!hasOverlap) {
        // No overlap, can use this branch
        assignedBranch = branchIndex;
        break;
      }
    }
    
    // If no existing branch can accommodate this entry, create a new side branch
    if (assignedBranch === -1) {
      assignedBranch = nextSideBranch++;
      activeBranches.push([]);
    }
    
    // Assign all commits for this entry to the chosen branch
    branchAssignments[key] = assignedBranch;
    activeBranches[assignedBranch].push(entry);
    
    console.log(`${entry.company} (${entry.era}) -> Branch ${assignedBranch} ${assignedBranch === 0 ? '(main)' : '(side)'}`);
  });
  
  // Apply branch assignments to commits
  allCommits.forEach(commit => {
    const key = commit.company + commit.era;
    commit.branch = branchAssignments[key];
  });
  
  // Create git graph visualization
  const canvas = document.getElementById('git-canvas');
  const ctx = canvas.getContext('2d');
  const commitsContainer = document.getElementById('git-commits');
  
  const BRANCH_WIDTH = 40;
  const LINE_HEIGHT = 30;
  const MAIN_BRANCH_X = 60; // X position of main branch
  
  // Calculate canvas dimensions
  const maxBranch = Math.max(...Object.values(branchAssignments));
  const totalHeight = allCommits.length * LINE_HEIGHT + 100;
  const totalWidth = MAIN_BRANCH_X + (maxBranch * BRANCH_WIDTH) + 100;
  
  // Set canvas size
  canvas.width = totalWidth;
  canvas.height = totalHeight;
  canvas.style.width = totalWidth + 'px';
  canvas.style.height = totalHeight + 'px';
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw git-style branch tree
  drawGitBranches(ctx, allCommits, branchAssignments);
  
  // Clear existing commits and recreate
  commitsContainer.innerHTML = '';
  
  // Position commits - simple line-by-line layout
  allCommits.forEach((commit, index) => {
    const yPosition = index * LINE_HEIGHT + 20; // Add padding from top
    const xPosition = getBranchX(commit.branch);
    
    // Create commit element
    const commitEl = document.createElement('div');
    commitEl.className = 'git-commit';
    commitEl.style.position = 'absolute';
    commitEl.style.left = (xPosition - 5) + 'px'; // Center dot on branch line
    commitEl.style.top = yPosition + 'px';
    
    // Commit dot
    const dot = document.createElement('div');
    dot.className = 'commit-dot';
    dot.style.width = '10px';
    dot.style.height = '10px';
    dot.style.borderRadius = '50%';
    dot.style.backgroundColor = getBranchColor(commit.branch);
    dot.style.border = '2px solid white';
    dot.style.position = 'absolute';
    
    // Commit info (date + company)
    const info = document.createElement('div');
    info.className = 'commit-info';
    info.style.position = 'absolute';
    info.style.left = '20px';
    info.style.top = '-8px';
    info.style.fontSize = '12px';
    info.style.whiteSpace = 'nowrap';
    
    const dateStr = commit.date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
    const typeStr = commit.type === 'end' ? ' (end)' : '';
    info.textContent = `${dateStr} - ${commit.company}${typeStr}`;
    
    commitEl.appendChild(dot);
    commitEl.appendChild(info);
    commitsContainer.appendChild(commitEl);
  });
  
  function getBranchX(branchIndex) {
    if (branchIndex === 0) return MAIN_BRANCH_X; // Main branch
    return MAIN_BRANCH_X + (branchIndex * BRANCH_WIDTH); // Side branches
  }
  
  function getBranchColor(branchIndex) {
    const colors = ['#2563eb', '#dc2626', '#059669', '#7c3aed', '#ea580c', '#f59e0b'];
    return colors[branchIndex] || '#666';
  }
  
  function drawGitBranches(ctx, commits, branchAssignments) {
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    // Draw main branch line (full height)
    ctx.strokeStyle = getBranchColor(0);
    ctx.beginPath();
    ctx.moveTo(MAIN_BRANCH_X, 0);
    ctx.lineTo(MAIN_BRANCH_X, totalHeight);
    ctx.stroke();
    
    // Find the start and end positions for each branch
    const branchRanges = {};
    
    console.log('=== DEBUG: Processing commits for branch ranges ===');
    commits.forEach((commit, index) => {
      const yPos = index * LINE_HEIGHT + 20;
      const branchIndex = commit.branch;
      
      console.log(`Commit ${index}: "${commit.company}" (${commit.type}) - Branch ${branchIndex} at yPos ${yPos}`);
      
      if (!branchRanges[branchIndex]) {
        branchRanges[branchIndex] = { top: yPos, bottom: yPos };
        console.log(`  -> New branch ${branchIndex}: top=${yPos}, bottom=${yPos}`);
      } else {
        branchRanges[branchIndex].bottom = yPos; // Since commits are sorted newest first, bottom is the last we see (chronologically earliest)
        console.log(`  -> Updated branch ${branchIndex}: top=${branchRanges[branchIndex].top}, bottom=${yPos}`);
      }
    });
    
    console.log('=== DEBUG: Final branch ranges ===');
    Object.keys(branchRanges).forEach(branchIndex => {
      const range = branchRanges[branchIndex];
      console.log(`Branch ${branchIndex}: top=${range.top}, bottom=${range.bottom} (height: ${range.bottom - range.top}px)`);
    });
    
    // Draw side branches
    Object.keys(branchRanges).forEach(branchIndex => {
      branchIndex = parseInt(branchIndex);
      if (branchIndex === 0) return; // Skip main branch
      
      const range = branchRanges[branchIndex];
      const sideX = getBranchX(branchIndex);
      
      console.log(`=== DEBUG: Drawing branch ${branchIndex} ===`);
      console.log(`  Side branch X: ${sideX}`);
      console.log(`  Vertical line from (${sideX}, ${range.bottom}) to (${sideX}, ${range.top})`);
      console.log(`  Horizontal fork line from (${MAIN_BRANCH_X}, ${range.bottom}) to (${sideX}, ${range.bottom})`);
      
      // Draw the vertical side branch line (from chronologically earliest to latest)
      ctx.strokeStyle = getBranchColor(branchIndex);
      ctx.beginPath();
      ctx.moveTo(sideX, range.bottom); // Start at chronologically earliest (bottom)
      ctx.lineTo(sideX, range.top); // End at chronologically latest (top)
      ctx.stroke();
      
      // Draw the horizontal fork line at the chronologically earliest point (where branch starts)
      ctx.strokeStyle = getBranchColor(branchIndex);
      ctx.beginPath();
      ctx.moveTo(MAIN_BRANCH_X, range.bottom);
      ctx.lineTo(sideX, range.bottom);
      ctx.stroke();
    });
  }
  
  // Set container heights
  commitsContainer.style.height = totalHeight + 'px';
  commitsContainer.style.position = 'relative';
});
</script>

<a href="#top" class="floating-back-to-top">
  <svg viewBox="0 0 24 24" fill="currentColor">
    <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
  </svg>
</a>



