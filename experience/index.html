---
layout: modern
title: "Experience"
---

<div class="page-header">
  <h1 class="page-title">Experience</h1>
  <p class="page-subtitle">Professional background, education, and expertise</p>
</div>

{% comment %}
Era navigation section
{% endcomment %}
<div class="tags-section">
  <h2>Jump to Era:</h2>
  <div class="tag-cloud">
    <a href="#era-professional" class="tag tag-link">Professional</a>
    <a href="#era-semi-pro" class="tag tag-link">Semi-Pro</a>
    <a href="#era-amateur" class="tag tag-link">Amateur</a>
    <a href="#era-higher-education" class="tag tag-link">Higher Education</a>
    <a href="#era-primary-education" class="tag tag-link">Primary Education</a>
    <a href="#era-foodservice" class="tag tag-link">Food Service</a>
  </div>
</div>

{% comment %}
Git-style timeline - start simple with just dates
{% endcomment %}

<div class="git-timeline-container">
  <h2>Career Timeline</h2>
  
  <!-- Git-style graph view -->
  <div class="git-graph">
    <canvas id="git-canvas" width="800" height="600"></canvas>
    
    <div class="git-commits" id="git-commits">
      <!-- Simple commit list with just dates -->
      {% for job in site.data.experience.experience %}
        <div class="git-commit" 
             data-start="{{ job.start }}"
             data-end="{{ job.end }}"
             data-company="{{ job.company }}"
             data-title="{{ job.title }}"
             data-era="{{ job.era }}">
          <div class="commit-dot"></div>
          <div class="commit-info">
            <span class="commit-date">{{ job.start }}{% if job.end %} - {{ job.end }}{% endif %}</span>
            <span class="commit-company">{{ job.company }}</span>
          </div>
        </div>
      {% endfor %}
      
      {% for edu in site.data.education.education %}
        <div class="git-commit" 
             data-start="{{ edu.start }}"
             data-end="{{ edu.end }}"
             data-company="{{ edu.institution }}"
             data-title="{{ edu.degree }}"
             data-era="education">
          <div class="commit-dot"></div>
          <div class="commit-info">
            <span class="commit-date">{{ edu.start }}{% if edu.end %} - {{ edu.end }}{% endif %}</span>
            <span class="commit-company">{{ edu.institution }}</span>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Simple date parser
  function parseDate(dateStr) {
    if (!dateStr) return null;
    dateStr = dateStr.trim();
    
    if (dateStr.includes('Current')) return new Date();
    
    // "January 2021" format
    const monthYearMatch = dateStr.match(/^([A-Za-z]+)\s+(\d{4})$/);
    if (monthYearMatch) {
      const month = new Date(Date.parse(monthYearMatch[1] + " 1, 2000")).getMonth();
      return new Date(parseInt(monthYearMatch[2]), month, 1);
    }
    
    // "2010" format  
    const yearMatch = dateStr.match(/^(\d{4})$/);
    if (yearMatch) {
      return new Date(parseInt(yearMatch[1]), 0, 1);
    }
    
    return null;
  }
  

  
  // Collect all commits (start and end dates)
  let allCommits = [];
  
  // Process experience items
  const commits = document.querySelectorAll('.git-commit');
  commits.forEach(commit => {
    const startDate = parseDate(commit.dataset.start);
    const endDate = parseDate(commit.dataset.end);
    const company = commit.dataset.company;
    const era = commit.dataset.era;
    
    // Skip commits with missing company data
    if (!company || company.trim() === '') {
      console.log(`Skipping commit with empty company: start="${commit.dataset.start}", end="${commit.dataset.end}", era="${era}"`);
      return;
    }
    
    // Add start commit
    if (startDate) {
      allCommits.push({
        date: startDate,
        company: company,
        type: 'start',
        era: era,
        element: commit,
        originalDate: commit.dataset.start // Store original start date string
      });
    }
    
    // Add end commit (if different from start)
    if (endDate && endDate.getTime() !== startDate?.getTime()) {
      allCommits.push({
        date: endDate,
        company: company,
        type: 'end',
        era: era,
        element: commit,
        originalDate: commit.dataset.end // Store original end date string
      });
    }
  });
  
  // Sort chronologically (newest first)
  allCommits.sort((a, b) => b.date - a.date);
  
  console.log('Total commits:', allCommits.length);
  
  // Assign branches - every experience gets its own branch
  // Main branch = empty trunk line
  // All experiences get dedicated side branches
  const branchAssignments = {};
  
  // Group commits by company+era to get their full date ranges
  const entryRanges = {};
  allCommits.forEach(commit => {
    const key = commit.company + commit.era;
    if (!entryRanges[key]) {
      entryRanges[key] = {
        company: commit.company,
        era: commit.era,
        start: commit.date,
        end: commit.date,
        commits: []
      };
    }
    entryRanges[key].commits.push(commit);
    
    // Update the range
    if (commit.date < entryRanges[key].start) entryRanges[key].start = commit.date;
    if (commit.date > entryRanges[key].end) entryRanges[key].end = commit.date;
  });
  
  // Sort entries by start date (earliest first)
  const sortedEntries = Object.values(entryRanges).sort((a, b) => a.start - b.start);
  
  console.log('=== DEBUG: Entry ranges ===');
  sortedEntries.forEach(entry => {
    console.log(`${entry.company} (${entry.era}): ${entry.start.toLocaleDateString()} - ${entry.end.toLocaleDateString()}`);
  });
  
  // Assign each experience a unique branch number for colors (skip branch 0 - it's the empty trunk)
  let nextBranch = 1; // Start from branch 1
  
  // Also create efficient horizontal positioning based on overlaps
  const branchPositions = {}; // Maps branch number to horizontal position index
  const activeBranches = []; // Track active ranges for efficient positioning
  let nextPosition = 1; // Start from position 1 (position 0 is main branch)
  
  console.log('=== DEBUG: Branch assignments ===');
  sortedEntries.forEach(entry => {
    const key = entry.company + entry.era;
    
    // Every experience gets its own unique branch number for color
    branchAssignments[key] = nextBranch++;
    
    // But for horizontal positioning, find the leftmost available position
    let assignedPosition = -1;
    
    for (let positionIndex = 0; positionIndex < activeBranches.length; positionIndex++) {
      const activeBranch = activeBranches[positionIndex];
      let hasOverlap = false;
      
      for (let activeEntry of activeBranch) {
        // Check if current entry overlaps with this active entry
        if (entry.start < activeEntry.end && entry.end > activeEntry.start) {
          hasOverlap = true;
          break;
        }
      }
      
      if (!hasOverlap) {
        // No overlap, can use this position
        assignedPosition = positionIndex + 1; // +1 because position 0 is main branch
        break;
      }
    }
    
    // If no existing position can accommodate this entry, create a new position
    if (assignedPosition === -1) {
      assignedPosition = nextPosition++;
      activeBranches.push([]);
    }
    
    // Map branch number to horizontal position
    branchPositions[branchAssignments[key]] = assignedPosition;
    activeBranches[assignedPosition - 1].push(entry); // -1 because activeBranches is 0-indexed but position numbers start from 1
    
    console.log(`${entry.company} (${entry.era}) -> Branch ${branchAssignments[key]} (color) -> Position ${assignedPosition} (horizontal)`);
  });
  
  // Apply branch assignments to commits
  allCommits.forEach(commit => {
    const key = commit.company + commit.era;
    commit.branch = branchAssignments[key];
  });
  
  // Create git graph visualization
  const canvas = document.getElementById('git-canvas');
  const ctx = canvas.getContext('2d');
  const commitsContainer = document.getElementById('git-commits');
  
  const BRANCH_WIDTH = 15;
  const LINE_HEIGHT = 30;
  const MAIN_BRANCH_X = 0; // Adjusted for removed padding
  
  // Calculate canvas dimensions
  const maxPosition = Math.max(...Object.values(branchPositions));
  const totalHeight = allCommits.length * LINE_HEIGHT + 100;
  const gitGraphWidth = MAIN_BRANCH_X + (maxPosition * BRANCH_WIDTH) + 10; // Minimal padding
  const textAreaX = gitGraphWidth + 10; // Text area starts very close to git graph
  
  // Set canvas size (just for the git graph)
  canvas.width = gitGraphWidth;
  canvas.height = totalHeight;
  canvas.style.width = gitGraphWidth + 'px';
  canvas.style.height = totalHeight + 'px';
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw git-style branch tree
  drawGitBranches(ctx, allCommits, branchAssignments);
  
  // Clear existing commits and recreate
  commitsContainer.innerHTML = '';
  
  // Position commits - simple line-by-line layout
  allCommits.forEach((commit, index) => {
    const yPosition = index * LINE_HEIGHT + 20; // Add padding from top
    const xPosition = getBranchX(commit.branch);
    
    // Create commit element
    const commitEl = document.createElement('div');
    commitEl.className = 'git-commit';
    commitEl.style.position = 'absolute';
    commitEl.style.left = (xPosition - 5) + 'px'; // Center dot on branch line
    commitEl.style.top = yPosition + 'px';
    
    // Commit dot
    const dot = document.createElement('div');
    dot.className = 'commit-dot';
    dot.style.width = '10px';
    dot.style.height = '10px';
    dot.style.borderRadius = '50%';
    dot.style.backgroundColor = getBranchColor(commit.branch);
    dot.style.border = '2px solid white';
    dot.style.position = 'absolute';
    
    // Commit info (date + company) - positioned in separate text area
    const info = document.createElement('div');
    info.className = 'commit-info';
    info.style.position = 'absolute';
    info.style.left = textAreaX + 'px'; // Position in text area, not relative to dot
    info.style.top = (yPosition - 8) + 'px'; // Align with commit dot vertically
    info.style.fontSize = '12px';
    info.style.whiteSpace = 'nowrap';
    
    // Use original date string instead of formatting parsed dates
    const typeStr = commit.type === 'end' ? ' (end)' : '';
    info.textContent = `${commit.originalDate} - ${commit.company}${typeStr}`;
    
    commitEl.appendChild(dot);
    // Add text directly to commits container instead of to individual commit element
    commitsContainer.appendChild(info);
    commitsContainer.appendChild(commitEl);
  });
  
  function getBranchX(branchIndex) {
    if (branchIndex === 0) return MAIN_BRANCH_X; // Main branch
    const position = branchPositions[branchIndex] || branchIndex; // Use position mapping, fallback to branch index
    return MAIN_BRANCH_X + (position * BRANCH_WIDTH); // Side branches
  }
  
  function getBranchColor(branchIndex) {
    const colors = [
      '#2563eb', // blue
      '#dc2626', // red
      '#059669', // green
      '#7c3aed', // purple
      '#ea580c', // orange
      '#f59e0b', // yellow
      '#0891b2', // cyan
      '#be185d', // pink
      '#65a30d', // lime
      '#c2410c', // red-orange
      '#7c2d12', // brown
      '#374151', // gray
      '#1e40af', // blue-700
      '#b91c1c', // red-700
      '#047857', // emerald-700
      '#6d28d9', // violet-700
      '#c2410c', // orange-700
      '#a16207', // yellow-700
      '#0e7490', // cyan-700
      '#be185d', // rose-700
    ];
    return colors[branchIndex % colors.length]; // Cycle through colors
  }
  
  function drawGitBranches(ctx, commits, branchAssignments) {
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    // Draw main branch line (full height)
    ctx.strokeStyle = getBranchColor(0);
    ctx.beginPath();
    ctx.moveTo(MAIN_BRANCH_X, 0);
    ctx.lineTo(MAIN_BRANCH_X, totalHeight);
    ctx.stroke();
    
    // Find the start and end positions for each branch
    const branchRanges = {};
    
    console.log('=== DEBUG: Processing commits for branch ranges ===');
    commits.forEach((commit, index) => {
      const yPos = index * LINE_HEIGHT + 20;
      const branchIndex = commit.branch;
      
      console.log(`Commit ${index}: "${commit.company}" (${commit.type}) - Branch ${branchIndex} at yPos ${yPos}`);
      
      if (!branchRanges[branchIndex]) {
        branchRanges[branchIndex] = { top: yPos, bottom: yPos };
        console.log(`  -> New branch ${branchIndex}: top=${yPos}, bottom=${yPos}`);
      } else {
        branchRanges[branchIndex].bottom = yPos; // Since commits are sorted newest first, bottom is the last we see (chronologically earliest)
        console.log(`  -> Updated branch ${branchIndex}: top=${branchRanges[branchIndex].top}, bottom=${yPos}`);
      }
    });
    
    console.log('=== DEBUG: Final branch ranges ===');
    Object.keys(branchRanges).forEach(branchIndex => {
      const range = branchRanges[branchIndex];
      console.log(`Branch ${branchIndex}: top=${range.top}, bottom=${range.bottom} (height: ${range.bottom - range.top}px)`);
    });
    
    // Draw individual vertical and horizontal lines for each entry
    console.log('=== DEBUG: Drawing individual entry lines ===');
    Object.values(entryRanges).forEach(entry => {
      const key = entry.company + entry.era;
      const branchIndex = branchAssignments[key];
      
      if (branchIndex === 0) return; // Skip main branch entries
      
      const sideX = getBranchX(branchIndex);
      
      // Find the Y positions of the entry's start and end commits
      const startCommit = allCommits.find((commit, index) => {
        return commit.company === entry.company && 
               commit.era === entry.era && 
               commit.type === 'start';
      });
      
      const endCommit = allCommits.find((commit, index) => {
        return commit.company === entry.company && 
               commit.era === entry.era && 
               commit.type === 'end';
      });
      
      if (startCommit) {
        const startCommitIndex = allCommits.findIndex(c => c === startCommit);
        const startY = startCommitIndex * LINE_HEIGHT + 20;
        
        // Draw the horizontal fork line at this entry's start point (aligned with dot center)
        ctx.strokeStyle = getBranchColor(branchIndex);
        ctx.beginPath();
        ctx.moveTo(MAIN_BRANCH_X, startY + 5); // +5px to align with center of 10px dot
        ctx.lineTo(sideX, startY + 5);
        ctx.stroke();
        
        console.log(`  Fork line for ${entry.company} (${entry.era}): from (${MAIN_BRANCH_X}, ${startY}) to (${sideX}, ${startY})`);
        
                          // Draw the vertical line for this entry only
         if (endCommit && endCommit !== startCommit) {
           const endCommitIndex = allCommits.findIndex(c => c === endCommit);
           const endY = endCommitIndex * LINE_HEIGHT + 20;
           
           ctx.strokeStyle = getBranchColor(branchIndex);
           ctx.beginPath();
           ctx.moveTo(sideX, startY + 5); // +5px to align with center of 10px dot
           ctx.lineTo(sideX, endY + 5);   // +5px to align with center of 10px dot
           ctx.stroke();
           
           console.log(`  Vertical line for ${entry.company} (${entry.era}): from (${sideX}, ${startY}) to (${sideX}, ${endY})`);
           
           // Draw merge line back to main branch if this entry has ended (not "current")
           const today = new Date();
           const daysDiff = Math.abs(endCommit.date - today) / (1000 * 60 * 60 * 24);
           
           if (daysDiff > 30) { // If end date is more than 30 days from today, it's not "current"
             ctx.strokeStyle = getBranchColor(branchIndex);
             ctx.beginPath();
             ctx.moveTo(sideX, endY + 5);
             ctx.lineTo(MAIN_BRANCH_X, endY + 5);
             ctx.stroke();
             
             console.log(`  Merge line for ${entry.company} (${entry.era}): from (${sideX}, ${endY}) back to main branch`);
           }
         }
      }
    });
  }
  
  // Set container dimensions to accommodate both git graph and text area
  commitsContainer.style.height = totalHeight + 'px';
  commitsContainer.style.width = (textAreaX + 300) + 'px'; // Extra space for text
  commitsContainer.style.position = 'relative';
});
</script>

<a href="#top" class="floating-back-to-top">
  <svg viewBox="0 0 24 24" fill="currentColor">
    <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
  </svg>
</a>
