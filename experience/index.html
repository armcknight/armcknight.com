---
layout: modern
title: "Experience"
---

<div class="page-header">
  <h1 class="page-title">Experience</h1>
  <p class="page-subtitle">Professional background, education, and expertise</p>
</div>

{% comment %}
Era navigation section
{% endcomment %}
<div class="tags-section">
  <h2>Jump to Era:</h2>
  <div class="tag-cloud">
    <a href="#era-professional" class="tag tag-link">Professional</a>
    <a href="#era-semi-pro" class="tag tag-link">Semi-Pro</a>
    <a href="#era-amateur" class="tag tag-link">Amateur</a>
    <a href="#era-higher-education" class="tag tag-link">Higher Education</a>
    <a href="#era-primary-education" class="tag tag-link">Primary Education</a>
    <a href="#era-foodservice" class="tag tag-link">Food Service</a>
  </div>
</div>

{% comment %}
Git-style timeline - start simple with just dates
{% endcomment %}

<div class="git-timeline-container">
  <h2>Career Timeline</h2>
  
  <!-- Git-style graph view -->
  <div class="git-graph">
    <canvas id="git-canvas" width="800" height="600"></canvas>
    
    <div class="git-commits" id="git-commits">
      <!-- Simple commit list with just dates -->
      {% for job in site.data.experience.experience %}
        <div class="git-commit" 
             data-start="{{ job.start }}"
             data-end="{{ job.end }}"
             data-company="{{ job.company }}"
             data-title="{{ job.title }}"
             data-location="{{ job.location }}"
             data-employment-type="{{ job.employment_type }}"
             data-highlights="{{ job.highlights | join: '||' }}"
             data-tags="{{ job.tags | join: ',' }}"
             data-stack="{{ job.stack | join: ',' }}"
             data-deliverables="{{ job.deliverables | jsonify | escape }}"
             data-era="{{ job.era }}">
          <div class="commit-dot"></div>
          <div class="commit-info">
            <span class="commit-date">{{ job.start }}{% if job.end %} - {{ job.end }}{% endif %}</span>
            <span class="commit-company">{{ job.company }}</span>
          </div>
        </div>
      {% endfor %}
      
      {% for edu in site.data.education.education %}
        <div class="git-commit" 
             data-start="{{ edu.start }}"
             data-end="{{ edu.end }}"
             data-company="{{ edu.institution }}"
             data-school="{{ edu.institution }}"
             data-title="{{ edu.degree }}"
             data-location="{{ edu.location }}"

             data-highlights="{{ edu.highlights | join: '||' }}"
             data-honors="{{ edu.honors | map: 'award' | join: '||' }}"
             data-tags="{{ edu.tags | join: ',' }}"
             data-era="education">
          <div class="commit-dot"></div>
          <div class="commit-info">
            <span class="commit-date">{{ edu.start }}{% if edu.end %} - {{ edu.end }}{% endif %}</span>
            <span class="commit-company">{{ edu.institution }}</span>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Simple date parser
  function parseDate(dateStr) {
    if (!dateStr) return null;
    dateStr = dateStr.trim();
    
    if (dateStr.includes('Current')) return new Date();
    
    // "January 2021" format
    const monthYearMatch = dateStr.match(/^([A-Za-z]+)\s+(\d{4})$/);
    if (monthYearMatch) {
      const month = new Date(Date.parse(monthYearMatch[1] + " 1, 2000")).getMonth();
      return new Date(parseInt(monthYearMatch[2]), month, 1);
    }
    
    // "2010" format  
    const yearMatch = dateStr.match(/^(\d{4})$/);
    if (yearMatch) {
      return new Date(parseInt(yearMatch[1]), 0, 1);
    }
    
    return null;
  }
  

  
  // Collect all commits (start and end dates)
  let allCommits = [];
  
  // Process experience items
  const commits = document.querySelectorAll('.git-commit');
  commits.forEach(commit => {
    const startDate = parseDate(commit.dataset.start);
    const endDate = parseDate(commit.dataset.end);
    // Check for both company and school/institution
    const company = commit.dataset.company || commit.dataset.school || commit.dataset.institution;
    const era = commit.dataset.era;
    
    // Skip commits with missing company/school data
    if (!company || company.trim() === '') {
      console.log(`Skipping commit with empty company/school: start="${commit.dataset.start}", end="${commit.dataset.end}", era="${era}"`);
      return;
    }
    
    // Add start commit
    if (startDate) {
      allCommits.push({
        date: startDate,
        company: company,
        type: 'start',
        era: era,
        element: commit,
        originalDate: commit.dataset.start // Store original start date string
      });
    }
    
    // Add end commit (if different from start)
    if (endDate && endDate.getTime() !== startDate?.getTime()) {
      allCommits.push({
        date: endDate,
        company: company,
        type: 'end',
        era: era,
        element: commit,
        originalDate: commit.dataset.end // Store original end date string
      });
    }
  });
  
  // Sort chronologically (newest first) - important for git graph branch logic
  allCommits.sort((a, b) => b.date - a.date);
  
  // Assign branches - every experience gets its own branch
  // Main branch = empty trunk line
  // All experiences get dedicated side branches
  const branchAssignments = {};
  
  // Group commits by company+era to get their full date ranges
  const entryRanges = {};
  allCommits.forEach(commit => {
    const key = commit.company + commit.era;
    if (!entryRanges[key]) {
      entryRanges[key] = {
        company: commit.company,
        era: commit.era,
        start: commit.date,
        end: commit.date,
        commits: []
      };
    }
    entryRanges[key].commits.push(commit);
    
    // Update the range
    if (commit.date < entryRanges[key].start) entryRanges[key].start = commit.date;
    if (commit.date > entryRanges[key].end) entryRanges[key].end = commit.date;
  });
  
  // Sort entries by start date (earliest first)
  const sortedEntries = Object.values(entryRanges).sort((a, b) => a.start - b.start);
  
  // Assign each experience a unique branch number for colors (skip branch 0 - it's the empty trunk)
  let nextBranch = 1; // Start from branch 1
  
  // Also create efficient horizontal positioning based on overlaps
  const branchPositions = {}; // Maps branch number to horizontal position index
  const activeBranches = []; // Track active ranges for efficient positioning
  let nextPosition = 1; // Start from position 1 (position 0 is main branch)
  
  sortedEntries.forEach(entry => {
    const key = entry.company + entry.era;
    
    // Every experience gets its own unique branch number for color
    branchAssignments[key] = nextBranch++;
    
    // But for horizontal positioning, find the leftmost available position
    let assignedPosition = -1;
    
    for (let positionIndex = 0; positionIndex < activeBranches.length; positionIndex++) {
      const activeBranch = activeBranches[positionIndex];
      let hasOverlap = false;
      
      for (let activeEntry of activeBranch) {
        // Check if current entry overlaps with this active entry
        if (entry.start < activeEntry.end && entry.end > activeEntry.start) {
          hasOverlap = true;
          break;
        }
      }
      
      if (!hasOverlap) {
        // No overlap, can use this position
        assignedPosition = positionIndex + 1; // +1 because position 0 is main branch
        break;
      }
    }
    
    // If no existing position can accommodate this entry, create a new position
    if (assignedPosition === -1) {
      assignedPosition = nextPosition++;
      activeBranches.push([]);
    }
    
    // Map branch number to horizontal position
    branchPositions[branchAssignments[key]] = assignedPosition;
    activeBranches[assignedPosition - 1].push(entry); // -1 because activeBranches is 0-indexed but position numbers start from 1
  });
  
  // Apply branch assignments to commits
  allCommits.forEach(commit => {
    const key = commit.company + commit.era;
    commit.branch = branchAssignments[key];
  });
  
  // Create git graph visualization
  const canvas = document.getElementById('git-canvas');
  const ctx = canvas.getContext('2d');
  const commitsContainer = document.getElementById('git-commits');
  
  const BRANCH_WIDTH = 15;
  const LINE_HEIGHT = 30;
  const MAIN_BRANCH_X = 0; // Adjusted for removed padding
  
  // Function to calculate actual rendered text height
  function calculateTextHeight(commit) {
    const element = commit.element;
    let content = '';
    
    if (commit.type === 'start') {
      // START COMMITS: Show contextual start information (minimal)
      content = `<strong>${commit.company} - Started ${commit.originalDate}</strong>`;
      
    } else {
      // END COMMITS: Show date range and all detailed information
      const startDate = element.dataset.start;
      const endDate = element.dataset.end;
      const isCurrentJob = endDate === 'Current';
      
      if (isCurrentJob) {
        content = `<strong>${commit.company} - ${startDate} to Present</strong>`;
      } else {
        content = `<strong>${commit.company} - ${startDate} - ${endDate}</strong>`;
      }
      
      // Add title if available
      if (element.dataset.title) {
        content += `<br/><em>${element.dataset.title}</em>`;
      }
      
      // Add location if available
      if (element.dataset.location) {
        content += `<br/>${element.dataset.location}`;
      }
      
      // Add employment type if available
      if (element.dataset.employmentType) {
        content += ` ${element.dataset.employmentType}`;
      }
      
      // Add highlights for experience and education entries
      if (element.dataset.highlights) {
        const highlights = element.dataset.highlights.split('||').slice(0, 4); // Show first 4 highlights
        highlights.forEach(highlight => {
          if (highlight.trim()) {
            content += `<br/>â€¢ ${highlight.trim()}`;
          }
        });
      }
      
      // Add education honors
      if (element.dataset.honors) {
        const honors = element.dataset.honors.split('||').slice(0, 3); // Show first 3 honors
        honors.forEach(honor => {
          if (honor.trim()) {
            content += `<br/>ðŸ† ${honor.trim()}`;
          }
        });
      }
      
      // Add technology stack for experience entries
      if (element.dataset.stack) {
        const stack = element.dataset.stack.split(',').map(s => s.trim()).filter(s => s);
        if (stack.length > 0) {
          content += `<br/><strong>Stack:</strong> ${stack.join(', ')}`;
        }
      }
      
      // Add deliverables for experience entries
      if (element.dataset.deliverables) {
        try {
          const deliverables = JSON.parse(element.dataset.deliverables);
          if (deliverables && deliverables.length > 0) {
            content += `<br/><strong>Deliverables:</strong>`;
            deliverables.forEach(deliverable => {
              if (typeof deliverable === 'string') {
                // Simple string format
                content += `<br/>â€¢ ${deliverable}`;
              } else if (deliverable.name) {
                // Object format with name/description
                content += `<br/>â€¢ ${deliverable.name}`;
                if (deliverable.description) {
                  content += ` - ${deliverable.description}`;
                }
              }
            });
          }
        } catch (e) {
          // Skip if JSON parsing fails
        }
      }
    }
    
    // Create a temporary element with exact same styling to measure actual height
    const tempElement = document.createElement('div');
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.fontSize = '1.125rem'; // --text-lg: match website body text
    tempElement.style.lineHeight = '1.75';   // match website body text
    tempElement.style.width = '500px';       // Reasonable width that fits with git graph
    tempElement.style.fontFamily = 'Charter, Georgia, Times New Roman, serif';
    tempElement.style.whiteSpace = 'normal';
    tempElement.innerHTML = content;
    
    // Add to document to measure, then remove
    document.body.appendChild(tempElement);
    const actualHeight = tempElement.offsetHeight;
    document.body.removeChild(tempElement);
    
    return actualHeight;
  }
  
  // NEW APPROACH: Text-first layout to prevent overlaps
  // 1. Layout text entries with regular spacing (no chronological gaps)
  // 2. Map git commit dots to text positions
  // 3. Draw git graph based on text-driven positions
  let cumulativeY = 20; // Start with padding from top
  const textPositions = [];
  
  // Layout all commits with fixed spacing to prevent overlaps
  allCommits.forEach((commit, index) => {
    const textHeight = calculateTextHeight(commit);
    const yPosition = cumulativeY;
    
    textPositions.push({
      commit: commit,
      yPosition: yPosition,
      textHeight: textHeight
    });
    
    // Use actual measured height + reasonable buffer
    const entrySpacing = textHeight + 30; // Actual height + 30px buffer
    cumulativeY += entrySpacing;
  });
  
  // Now map git commit dots to text positions (adapting git graph to text layout)
  const commitPositions = textPositions.map(textPos => ({
    commit: textPos.commit,
    yPosition: textPos.yPosition + 5, // Center dot vertically with first line of text
    textHeight: textPos.textHeight
  }));
  
  // Calculate canvas dimensions
  const maxPosition = Math.max(...Object.values(branchPositions));
  const totalHeight = cumulativeY + 50; // Use actual cumulative height + padding
  const gitGraphWidth = MAIN_BRANCH_X + (maxPosition * BRANCH_WIDTH) + 10; // Minimal padding
  const textAreaX = gitGraphWidth + 10; // Text area starts very close to git graph
  
  // Set canvas size (just for the git graph)
  canvas.width = gitGraphWidth;
  canvas.height = totalHeight;
  canvas.style.width = gitGraphWidth + 'px';
  canvas.style.height = totalHeight + 'px';
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw git-style branch tree using text-driven positions
  drawGitBranches(ctx, allCommits, branchAssignments, commitPositions);
  
  // Clear existing commits and recreate
  commitsContainer.innerHTML = '';
  // Position commits using text-first approach
  textPositions.forEach((textPos, index) => {
    const commit = textPos.commit;
    const textY = textPos.yPosition;
    const dotY = commitPositions[index].yPosition; // Use mapped commit position for dot
    const xPosition = getBranchX(commit.branch);
    
    // Create commit element (for the dot)
    const commitEl = document.createElement('div');
    commitEl.className = 'git-commit';
    commitEl.style.position = 'absolute';
    commitEl.style.left = (xPosition - 5) + 'px'; // Center 10px dot on branch line
    commitEl.style.top = dotY + 'px'; // Use dot position for the actual dot
    
    // Debug: Check exact dot positioning
    console.log(`Dot ${commit.company}: positioned at (${xPosition - 5}, ${dotY}), center at (${xPosition}, ${dotY + 5})`);
    
    // Commit dot
    const dot = document.createElement('div');
    dot.className = 'commit-dot';
    dot.style.width = '10px';
    dot.style.height = '10px';
    dot.style.borderRadius = '50%';
    dot.style.backgroundColor = getBranchColor(commit.branch);
    dot.style.border = '2px solid white';
    dot.style.position = 'absolute';
    
    // Commit info (rich multi-line content) - positioned based on text layout
    const info = document.createElement('div');
    info.className = 'commit-info';
    info.style.position = 'absolute';
    info.style.left = textAreaX + 'px'; // Position in text area, not relative to dot
    info.style.top = textY + 'px'; // Use text position for the text (no offset needed)
    info.style.fontSize = '1.125rem'; // --text-lg: match website body text
    info.style.lineHeight = '1.75';   // match website body text
    info.style.width = '500px';       // Reasonable width that fits with git graph
    info.style.fontFamily = 'Charter, Georgia, Times New Roman, serif';
    info.style.whiteSpace = 'normal'; // Allow wrapping for multi-line content
    
    // Build content based on commit type
    const element = commit.element;
    let content = '';
    
    if (commit.type === 'start') {
      // START COMMITS: Show contextual start information (minimal)
      content = `<strong>${commit.company} - Started ${commit.originalDate}</strong>`;
      
    } else {
      // END COMMITS: Show date range and all detailed information
      const startDate = element.dataset.start;
      const endDate = element.dataset.end;
      const isCurrentJob = endDate === 'Current';
      
      if (isCurrentJob) {
        content = `<strong>${commit.company} - ${startDate} to Present</strong>`;
      } else {
        content = `<strong>${commit.company} - ${startDate} - ${endDate}</strong>`;
      }
      
      // Add title if available
      if (element.dataset.title) {
        content += `<br/><em>${element.dataset.title}</em>`;
      }
      
      // Add location if available
      if (element.dataset.location) {
        content += `<br/>${element.dataset.location}`;
      }
      
      // Add employment type if available
      if (element.dataset.employmentType) {
        content += ` ${element.dataset.employmentType}`;
      }
      
      // Add highlights for experience and education entries
      if (element.dataset.highlights) {
        const highlights = element.dataset.highlights.split('||').slice(0, 4); // Show first 4 highlights
        highlights.forEach(highlight => {
          if (highlight.trim()) {
            content += `<br/>â€¢ ${highlight.trim()}`;
          }
        });
      }
      
      // Add education honors
      if (element.dataset.honors) {
        const honors = element.dataset.honors.split('||').slice(0, 3); // Show first 3 honors
        honors.forEach(honor => {
          if (honor.trim()) {
            content += `<br/>ðŸ† ${honor.trim()}`;
          }
        });
      }
      
      // Add technology stack for experience entries
      if (element.dataset.stack) {
        const stack = element.dataset.stack.split(',').map(s => s.trim()).filter(s => s);
        if (stack.length > 0) {
          content += `<br/><strong>Stack:</strong> ${stack.join(', ')}`;
        }
      }
      
      // Add deliverables for experience entries
      if (element.dataset.deliverables) {
        try {
          const deliverables = JSON.parse(element.dataset.deliverables);
          if (deliverables && deliverables.length > 0) {
            content += `<br/><strong>Deliverables:</strong>`;
            deliverables.forEach(deliverable => {
              if (typeof deliverable === 'string') {
                // Simple string format
                content += `<br/>â€¢ ${deliverable}`;
              } else if (deliverable.name) {
                // Object format with name/description
                content += `<br/>â€¢ ${deliverable.name}`;
                if (deliverable.description) {
                  content += ` - ${deliverable.description}`;
                }
              }
            });
          }
        } catch (e) {
          // Skip if JSON parsing fails
        }
      }
    }
    
    info.innerHTML = content;
    
    commitEl.appendChild(dot);
    // Add text directly to commits container instead of to individual commit element
    commitsContainer.appendChild(info);
    commitsContainer.appendChild(commitEl);
  });
  
  function getBranchX(branchIndex) {
    if (branchIndex === 0) return MAIN_BRANCH_X; // Main branch
    const position = branchPositions[branchIndex] || branchIndex; // Use position mapping, fallback to branch index
    const result = MAIN_BRANCH_X + (position * BRANCH_WIDTH); // Side branches
    return result;
  }
  
  function getBranchColor(branchIndex) {
    const colors = [
      '#2563eb', // blue
      '#dc2626', // red
      '#059669', // green
      '#7c3aed', // purple
      '#ea580c', // orange
      '#f59e0b', // yellow
      '#0891b2', // cyan
      '#be185d', // pink
      '#65a30d', // lime
      '#c2410c', // red-orange
      '#7c2d12', // brown
      '#374151', // gray
      '#1e40af', // blue-700
      '#b91c1c', // red-700
      '#047857', // emerald-700
      '#6d28d9', // violet-700
      '#c2410c', // orange-700
      '#a16207', // yellow-700
      '#0e7490', // cyan-700
      '#be185d', // rose-700
    ];
    return colors[branchIndex % colors.length]; // Cycle through colors
  }
  
  function drawGitBranches(ctx, commits, branchAssignments, commitPositions) {
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    // Draw main branch line (full height)
    ctx.strokeStyle = getBranchColor(0);
    ctx.beginPath();
    ctx.moveTo(MAIN_BRANCH_X, 0);
    ctx.lineTo(MAIN_BRANCH_X, totalHeight);
    ctx.stroke();
    
    // Find the start and end positions for each branch
    const branchRanges = {};
    
    commits.forEach((commit, index) => {
      const yPos = commitPositions[index].yPosition; // Use actual Y position from commitPositions
      const branchIndex = commit.branch;
      
      if (!branchRanges[branchIndex]) {
        branchRanges[branchIndex] = { top: yPos, bottom: yPos };
      } else {
        branchRanges[branchIndex].bottom = yPos; // Since commits are sorted newest first, bottom is the last we see (chronologically earliest)
      }
    });
    
    // Draw individual vertical and horizontal lines for each entry
    Object.values(entryRanges).forEach(entry => {
      const key = entry.company + entry.era;
      const branchIndex = branchAssignments[key];
      
      if (branchIndex === 0) return; // Skip main branch entries
      
      const sideX = getBranchX(branchIndex);
      
      // Find the Y positions of the entry's start and end commits
      const startCommit = allCommits.find((commit, index) => {
        return commit.company === entry.company && 
               commit.era === entry.era && 
               commit.type === 'start';
      });
      
      const endCommit = allCommits.find((commit, index) => {
        return commit.company === entry.company && 
               commit.era === entry.era && 
               commit.type === 'end';
      });
      
      if (startCommit) {
        const startCommitIndex = allCommits.findIndex(c => c === startCommit);
        const startY = commitPositions[startCommitIndex].yPosition;
        
        // Calculate coordinated curve offsets for symmetry
        const horizontalDistance = sideX - MAIN_BRANCH_X;
        const idealOffset = horizontalDistance;
        
        let forkStartOffset = idealOffset;
        let mergeEndOffset = idealOffset;
        
        // If there's both a start and end commit, coordinate the curves
        if (endCommit && endCommit !== startCommit) {
          const endCommitIndex = allCommits.findIndex(c => c === endCommit);
          const endY = commitPositions[endCommitIndex].yPosition;
          
          // Calculate available space to avoid intersections
          const nextCommitIndex = endCommitIndex - 1; // Next chronologically newer commit
          
          if (nextCommitIndex >= 0) {
            // There's a next commit - calculate total available space
            const nextCommitY = commitPositions[nextCommitIndex].yPosition;
            const totalAvailableSpace = startY - nextCommitY - 20; // 20px buffer
            const requiredSpace = forkStartOffset + mergeEndOffset;
            
            // If we need more space than available, scale both curves proportionally
            if (requiredSpace > totalAvailableSpace) {
              const scaleFactor = totalAvailableSpace / requiredSpace;
              forkStartOffset *= scaleFactor;
              mergeEndOffset *= scaleFactor;
            }
          }
        }
        
        // Draw the curved fork line at this entry's start point (aligned with dot center)
        ctx.strokeStyle = getBranchColor(branchIndex);
        ctx.beginPath();
        
        // Create a smooth gitgraph.js-style curve from vertical main branch to horizontal branch
        const curveStart = startY + 5 + forkStartOffset; // Start point on main branch (below the commit)
        const curveEnd = startY + 5; // End point on horizontal branch line (at commit level)
        
        // Use cubic Bezier curve with control points for smooth S-curve transition
        const controlDistance = horizontalDistance * 0.5; // How far out the control points extend
        
        ctx.moveTo(MAIN_BRANCH_X, curveStart);
        ctx.bezierCurveTo(
          MAIN_BRANCH_X, curveStart - controlDistance, // First control point (pull vertically from start)
          sideX, curveEnd + controlDistance,           // Second control point (pull vertically from end)
          sideX, curveEnd                              // End point
        );
        ctx.stroke();
        
                          // Draw the vertical line for this entry only
         if (endCommit && endCommit !== startCommit) {
           const endCommitIndex = allCommits.findIndex(c => c === endCommit);
           const endY = commitPositions[endCommitIndex].yPosition;
           
           ctx.strokeStyle = getBranchColor(branchIndex);
           ctx.beginPath();
           ctx.moveTo(sideX, startY + 5); // +5px to align with center of 10px dot
           ctx.lineTo(sideX, endY + 5);   // +5px to align with center of 10px dot
           ctx.stroke();
           
           // Draw curved merge line back to main branch if this entry has ended (not "current")
           if (endCommit.originalDate !== 'Current') { // If end date is not "Current"
               ctx.strokeStyle = getBranchColor(branchIndex);
               ctx.beginPath();
               
                                // Create a smooth gitgraph.js-style curve from horizontal branch to vertical main branch
                 const mergeStart = endY + 5; // Start point on horizontal branch line (at commit level)
                 const mergeHorizontalDistance = sideX - MAIN_BRANCH_X;
                 
                 // Use the coordinated merge end offset for symmetry
                 const mergeEnd = endY + 5 - mergeEndOffset; // Use coordinated offset
               
               // Use cubic Bezier curve with control points for smooth S-curve transition
               const mergeControlDistance = mergeHorizontalDistance * 0.5; // How far out the control points extend
               
               ctx.moveTo(sideX, mergeStart);
               ctx.bezierCurveTo(
                 sideX, mergeStart - mergeControlDistance, // First control point (pull vertically from start)
                 MAIN_BRANCH_X, mergeEnd + mergeControlDistance, // Second control point (pull vertically from end)
                 MAIN_BRANCH_X, mergeEnd                   // End point on main branch
               );
               ctx.stroke();
             }
         }
      }
    });
  }
  
  // Set container dimensions to accommodate both git graph and text area
  commitsContainer.style.height = totalHeight + 'px';
  commitsContainer.style.width = (textAreaX + 500) + 'px'; // Extra space for text area
  commitsContainer.style.position = 'relative';
});
</script>

<a href="#top" class="floating-back-to-top">
  <svg viewBox="0 0 24 24" fill="currentColor">
    <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
  </svg>
</a>
